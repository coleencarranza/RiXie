######################################################################
######################### VULNERABILITY DATA #########################
######################################################################
library(sf)
source("./RCode/GeneralFunctions.R")
source("./RCode/AdminBoundaries.R")


GetSHDI<-function(ADM,ISO){
  SHDI<-read.csv2(paste0(dir,"/Data/Vulnerability/SHDI-Database.csv"),sep = ";")
  # Keep only the most recent year, sub-national data and the data from the country of interest
  SHDI%<>%group_by(iso_code)%>%filter(year==max(year) & iso_code==ISO & level=="Subnat")%>%
          dplyr::select(c(1,4,6:(ncol(SHDI)-1)))%>%as.data.frame()
  colnames(SHDI)[4:ncol(SHDI)]<-c("SHDI","HealthI","LivingStandI","EducationI","LifeExp","GrossNatInc","ExpectedSchoolYrs","MeanSchoolYrs")
  # Convert to numeric
  for(i in 4:ncol(SHDI)) SHDI[,i]<-as.numeric(SHDI[,i])
  # We don't want the log of the Gross National Income
  SHDI$GrossNatInc%<>%exp()
  # Get the polygon shapefile of the admin boundaries of the SHDI database
  SHDIpoly<-GetSHDIadmin(ISO)
  # Find which indices in the SHDI object correspond to ADM values
  # indies<-Poly2poly(SHDIpoly,ADM,SHDI)
  # Do this by checking for overlap with other boundaries
  crs(SHDIpoly)<-crs(ADM)
  ADM$GDLCODE<-vapply(1:nrow(ADM@data), function(i) over(ADM[i,],SHDIpoly)$gdlcode,
                      FUN.VALUE = character(1))
  # Bind the ADM data.frame with the GDL values
  # ADM$GDLCODE<-indies%>%arrange(indexADM)%>%pull(GDLCODE)
  ADM@data%<>%merge(dplyr::select(SHDI,-iso_code),by="GDLCODE",all.x=T)
  
  return(ADM)
}

#------------------------------------------------------------
##--Extracting data from SHDI polygons 
#------------------------------------------------------------
GetSHDI_per_UNlvl2<-function(iso){
  #Read ADM UN and SHDI
  ADM_sub<-GetUNMaps(iso)
  gdl <- sf::st_read("./Data/AdminBoundaries/GDL/GDL Shapefiles V6/shdi2022_World_large.shp",quiet=TRUE)
  st_crs(gdl) <- st_crs(ADM_sub)
  gdl <- gdl[!is.na(gdl$iso_code) & gdl$iso_code ==iso, ]
  ADM2CD<-unique(ADM_sub$ADM2CD) %>%
    .[!is.na(.)]
  #treat it polygon per polygon:
  if(nrow(ADM_sub)>1){
    ADM_per_poly<-split(ADM_sub, f = ADM_sub[["ADM2CD"]])#prefer to split using codes because names can duplicate
  }else{
    ADM_per_poly<-list(ADM_sub)
  }
  #consider different cases overlaps between ADM and SHDI polygons
  gdl_per_ADM<-list()
  if(nrow(ADM_sub) >= nrow(gdl)){ #means ADM maps smaller than SHDI
    for(i in seq_along(ADM_per_poly)){
      tryCatch(
        {
          p<-ADM_per_poly[[i]]
          pt_surf<-st_point_on_surface(p)#not necessarily centroid.
          #extract/subset
          gdl_per_ADM[[i]]<-gdl[pt_surf,]
        },
        error = function(e) {}
      )
    }
  } else { #means ADM maps larger than SHDI
    for(i in seq_along(ADM_per_poly)){
      tryCatch(
        {
          p<-ADM_per_poly[[i]]
          #extract/subset that intersects
          gdl_per_ADM[[i]]<-gdl[st_intersects(gdl,p,sparse=FALSE),] 
        },
        error = function(e) {}
        
      )
    }
  }
  #match with GDL database:
  GDL_db<-read.csv("./Data/Vulnerability/SHDI-SGDI-Total 5.0.csv",header=TRUE,stringsAsFactors = FALSE) %>%
    filter(iso_code == iso)
  #for empty data frames: grr!
  for(i in seq_along(gdl_per_ADM)){
    g<-gdl_per_ADM[[i]] %>%
      st_drop_geometry()
    if(nrow(g) ==0)
      g[1, ] <- rep(NA,ncol(g))
    gdl_per_ADM[[i]]<-g
    }
  
  gdl_per_ADM%<>%bind_rows()%>%
    cbind(ADM2CD,.) %>%
    dplyr::select(c("ADM2CD","gdlcode"))%>%
    left_join(GDL_db, by=c("gdlcode"="GDLCODE"))
 
  return(gdl_per_ADM)
}


